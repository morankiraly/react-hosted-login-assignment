"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.afterAuthNavigation = afterAuthNavigation;
exports.getMfaRequiredState = getMfaRequiredState;
exports.isMfaRequired = void 0;
exports.loadSSOPublicConfigurationFunction = loadSSOPublicConfigurationFunction;
exports.loginSagas = loginSagas;
exports.loginSagasMock = loginSagasMock;
exports.refreshMetadata = refreshMetadata;
exports.refreshToken = refreshToken;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _effects = require("redux-saga/effects");

var _restApi = require("@frontegg/rest-api");

var _reducer = require("../reducer");

var _constants = require("../../constants");

var _interfaces = require("../interfaces");

var _interfaces2 = require("./interfaces");

var _saga = require("../SignUp/saga");

var _interfaces3 = require("../MfaState/interfaces");

var _dummy = require("../dummy");

var _interfaces4 = require("../SSOState/interfaces");

var _saga2 = require("../../vendor/saga");

var _helpers = require("../../helpers");

var _interfaces5 = require("../ResetPhoneNumberState/interfaces");

var _utils = require("../utils");

var _saga3 = require("../SecurityPolicyState/saga");

const _excluded = ["callback"],
      _excluded2 = ["callback"],
      _excluded3 = ["callback"],
      _excluded4 = ["callback"],
      _excluded5 = ["callback", "events"],
      _excluded6 = ["callback"],
      _excluded7 = ["callback"],
      _excluded8 = ["callback"],
      _excluded9 = ["callback"],
      _excluded10 = ["callback"],
      _excluded11 = ["callback"],
      _excluded12 = ["callback"],
      _excluded13 = ["callback"],
      _excluded14 = ["callback"],
      _excluded15 = ["callback", "deviceId"],
      _excluded16 = ["callback", "deviceId"],
      _excluded17 = ["callback", "deviceId"],
      _excluded18 = ["callback", "deviceId"];
const authStrategyLoginStepMap = {
  [_restApi.AuthStrategyEnum.Code]: _interfaces2.LoginStep.loginWithOtc,
  [_restApi.AuthStrategyEnum.EmailAndPassword]: _interfaces2.LoginStep.loginWithPassword,
  [_restApi.AuthStrategyEnum.MagicLink]: _interfaces2.LoginStep.magicLinkPreLoginSuccess,
  [_restApi.AuthStrategyEnum.SmsCode]: _interfaces2.LoginStep.loginWithSmsOtc
};

function* afterAuthNavigation() {
  var _window;

  const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
  const {
    routes,
    includeQueryParam
  } = yield (0, _effects.select)(state => state.auth);
  const {
    loginUrl,
    logoutUrl,
    socialLoginCallbackUrl,
    activateUrl
  } = routes;
  let {
    authenticatedUrl
  } = routes;
  const afterAuthRedirect = window.localStorage.getItem(_constants.FRONTEGG_AFTER_AUTH_REDIRECT_URL);

  if (afterAuthRedirect && ![loginUrl, logoutUrl, socialLoginCallbackUrl, activateUrl].includes(afterAuthRedirect)) {
    authenticatedUrl = afterAuthRedirect;
  }

  window.localStorage.removeItem(_constants.FRONTEGG_AFTER_AUTH_REDIRECT_URL);
  yield (0, _effects.delay)(200);
  (0, _effects.put)(_reducer.actions.resetLoginState());
  const url = new URL((_window = window) == null ? void 0 : _window.location.href);
  let redirectUrl = authenticatedUrl;

  if (url.searchParams.get('redirectUrl')) {
    var _url$searchParams$get;

    redirectUrl = (_url$searchParams$get = url.searchParams.get('redirectUrl')) != null ? _url$searchParams$get : authenticatedUrl;
  } else if (includeQueryParam) {
    redirectUrl += window.location.search;
  }

  onRedirectTo(redirectUrl, {
    refresh: redirectUrl.startsWith('http')
  });
}

function* refreshMetadata() {
  let ssoACS;

  try {
    var _metadata$configurati;

    const metadata = yield (0, _effects.call)(_restApi.api.metadata.getSamlMetadata);
    ssoACS = metadata == null ? void 0 : (_metadata$configurati = metadata.configuration) == null ? void 0 : _metadata$configurati.acsUrl;
  } catch (e) {
    console.error(e);
  }

  yield (0, _effects.put)(_reducer.actions.setState({
    ssoACS
  }));
}

function* loadSSOPublicConfigurationFunction() {
  try {
    const {
      isActive
    } = yield (0, _effects.call)(_restApi.api.auth.getSSOPublicConfiguration);
    yield (0, _effects.put)(_reducer.actions.setState({
      isSSOAuth: isActive
    }));
  } catch (e) {
    console.error(e);
  }
}

const isMfaRequired = user => {
  if (user.mfaRequired && user.mfaToken) {
    _restApi.ContextHolder.setAccessToken(null);

    _restApi.ContextHolder.setUser(null);

    return true;
  } else {
    _restApi.ContextHolder.setAccessToken(user.accessToken);

    _restApi.ContextHolder.setUser(user);

    return false;
  }
};

exports.isMfaRequired = isMfaRequired;

const getNumberOfMfaDevices = mfaDevices => {
  const numberOfWebAuthnDevices = +Boolean(mfaDevices.webauthn.length);
  const numberOfPhoneDevices = +Boolean(mfaDevices.phones.length);
  const numberOfAuthenticators = +Boolean(mfaDevices.authenticators.length);
  const totalDevices = numberOfWebAuthnDevices + numberOfPhoneDevices + numberOfAuthenticators;
  return {
    numberOfWebAuthnDevices,
    numberOfPhoneDevices,
    numberOfAuthenticators,
    totalDevices
  };
};

const getMfaStepForEnrolledUsers = mfaDevices => {
  const {
    numberOfPhoneDevices,
    numberOfAuthenticators,
    totalDevices
  } = getNumberOfMfaDevices(mfaDevices);

  if (totalDevices === 1) {
    if (numberOfAuthenticators) {
      return _interfaces3.MFAStep.authenticatorApp;
    } else if (numberOfPhoneDevices) {
      return _interfaces3.MFAStep.smsVerifyCode;
    }
  }

  return _interfaces3.MFAStep.verify;
};

const getMfaStepForNotEnrolledUsers = mfaStrategies => {
  if (mfaStrategies.length === 1) {
    const [strategy] = mfaStrategies;

    if (strategy === _restApi.MFAStrategyEnum.AuthenticatorApp) {
      return _interfaces3.MFAStep.authenticatorApp;
    } else if (strategy === _restApi.MFAStrategyEnum.SMS) {
      return _interfaces3.MFAStep.smsSetPhoneNumber;
    }
  }

  return _interfaces3.MFAStep.verify;
};

function* getMfaRequiredState(user) {
  let step = _interfaces2.LoginStep.loginWithTwoFactor;
  let mfaState = {};
  const {
    loginState
  } = yield (0, _effects.select)(state => state.auth);
  const {
    isAllowedToRemember,
    mfaDeviceExpiration
  } = yield (0, _effects.call)(_restApi.api.auth.checkIfAllowToRememberMfaDevice, user.mfaToken);
  const isEnrolled = !(user.hasOwnProperty('mfaEnrolled') && !user.mfaEnrolled);

  if (isEnrolled) {
    mfaState = {
      mfaDevices: user.mfaDevices,
      step: getMfaStepForEnrolledUsers(user.mfaDevices)
    };
  } else {
    mfaState = {
      step: getMfaStepForNotEnrolledUsers(user.mfaStrategies),
      qrCode: user.qrCode,
      recoveryCode: user.recoveryCode,
      loading: false,
      mfaToken: user.mfaToken,
      mfaStrategies: user.mfaStrategies
    };
    step = _interfaces2.LoginStep.forceTwoFactor;
  }

  let quickLoginState = {};
  const quickLoginToRegister = localStorage.getItem('register-quick-login');

  if (quickLoginToRegister) {
    quickLoginState = {
      quickLoginToRegister,
      flow: _interfaces2.LoginFlow.RegisterQuickLogin
    };
  }

  return {
    user: undefined,
    isAuthenticated: false,
    mfaState,
    loginState: (0, _extends2.default)({}, loginState, quickLoginState, {
      mfaToken: user.mfaToken,
      mfaRequired: user.mfaRequired,
      loading: false,
      error: undefined,
      step,
      tenantsLoading: true,
      email: user.userEmail,
      tenants: [],
      allowRememberMfaDevice: isAllowedToRemember,
      mfaDeviceExpiration
    })
  };
}

function* refreshToken() {
  const {
    hostedLoginBox
  } = yield (0, _effects.select)(state => state.auth);

  if (hostedLoginBox) {
    yield (0, _effects.call)(refreshTokenHosted);
  } else {
    yield (0, _effects.call)(refreshTokenEmbedded);
  }
}

function* refreshTokenHosted() {
  const {
    user
  } = yield (0, _effects.select)(state => state.auth);

  if (!(user != null && user.refreshToken)) {
    _restApi.ContextHolder.setAccessToken(null);

    _restApi.ContextHolder.setUser(null);

    yield (0, _effects.put)(_reducer.actions.setState({
      user: null,
      isAuthenticated: false
    }));
    return;
  }

  try {
    const body = {
      grant_type: 'refresh_token',
      refresh_token: user == null ? void 0 : user.refreshToken
    };
    const authenticatedUser = yield (0, _effects.call)(_restApi.api.auth.exchangeOAuthTokens, body);
    yield (0, _effects.put)(_reducer.actions.setState({
      user: authenticatedUser,
      isAuthenticated: true
    }));
    yield (0, _effects.put)(_reducer.actions.loadTenants());
  } catch (e) {
    _restApi.ContextHolder.setAccessToken(null);

    _restApi.ContextHolder.setUser(null);

    yield (0, _effects.put)(_reducer.actions.setState({
      user: null,
      isAuthenticated: false
    }));
  }
}

function* refreshTokenEmbedded() {
  try {
    const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
    const {
      routes,
      loginState
    } = yield (0, _effects.select)(state => state.auth);
    const {
      user,
      tenants
    } = yield (0, _effects.call)(_restApi.api.auth.refreshTokenV2);

    if (isMfaRequired(user)) {
      const mfaRequiredState = yield getMfaRequiredState(user);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      var _ref, _window2;

      if (user.id) {
        localStorage.setItem('userId', user.id);
      }

      const quickLoginToRegister = (_ref = localStorage.getItem('register-quick-login')) != null ? _ref : loginState.quickLoginToRegister;
      const shouldNavigateToRegisterQuickLogin = quickLoginToRegister && localStorage.getItem(`${user.id}-${quickLoginToRegister}`) !== 'true' && !window.location.pathname.endsWith(routes.logoutUrl);
      yield (0, _effects.put)(_reducer.actions.setTenantsState({
        tenants,
        loading: false
      }));
      yield (0, _effects.put)(_reducer.actions.setState({
        user,
        isAuthenticated: true,
        loginState: (0, _extends2.default)({}, loginState, {
          quickLoginToRegister,
          flow: shouldNavigateToRegisterQuickLogin ? _interfaces2.LoginFlow.RegisterQuickLogin : _interfaces2.LoginFlow.Login
        })
      }));
      const url = new URL((_window2 = window) == null ? void 0 : _window2.location.href);
      const invitationToken = url.searchParams.get('invitationToken');
      const redirectRoutes = [routes.socialLoginCallbackUrl, routes.oidcRedirectUrl, routes.samlCallbackUrl];

      if (!invitationToken) {
        redirectRoutes.push(routes.loginUrl, routes.signUpUrl);
      }

      if (shouldNavigateToRegisterQuickLogin) {
        onRedirectTo(routes.loginUrl);
      } else if (redirectRoutes.some(url => url && window.location.pathname.endsWith(url))) {
        if (loginState.isNewUser && routes.signUpSuccessUrl && routes.socialLoginCallbackUrl === window.location.pathname) {
          onRedirectTo(routes.signUpSuccessUrl, {
            refresh: routes.signUpSuccessUrl.startsWith('http')
          });
        } else {
          yield afterAuthNavigation();
        }
      }
    }
  } catch (e) {
    _restApi.ContextHolder.setAccessToken(null);

    _restApi.ContextHolder.setUser(null);

    yield (0, _effects.put)(_reducer.actions.setState({
      user: undefined,
      isAuthenticated: false
    }));
  }
}

function* getUserIP({
  payload: {
    callback
  }
}) {
  try {
    const {
      ip
    } = yield (0, _effects.call)(_restApi.api.metadata.getCurrentUserIpMetadata);
    yield (0, _effects.put)(_reducer.actions.setState({
      userIp: ip
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    callback == null ? void 0 : callback(false);
  }
}

function* requestAuthorize({
  payload: firstTime
}) {
  const calls = [];

  if (firstTime) {
    yield (0, _effects.put)(_reducer.actions.setState({
      isLoading: true
    }));
    yield (0, _effects.put)(_reducer.actions.loadSocialLoginsConfigurationV2());
    calls.push((0, _effects.call)(_saga.loadAllowSignUps));
    calls.push((0, _effects.call)(_saga3.loadPublicAuthStrategiesPolicy));
    calls.push((0, _effects.call)(loadSSOPublicConfigurationFunction));
    calls.push((0, _effects.call)(_saga2.loadVendorPublicInfo));
    calls.push((0, _effects.call)(refreshMetadata));
  }

  calls.push((0, _effects.call)(refreshToken));
  yield (0, _effects.all)(calls);
  yield (0, _effects.put)(_reducer.actions.setState({
    isLoading: false
  }));
}

function* isMFARequiredSSR({
  accessToken,
  user
}) {
  if (!accessToken) {
    yield (0, _effects.put)(_reducer.actions.setState({
      user: undefined,
      isAuthenticated: false
    }));
    return;
  }

  const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
  const {
    routes
  } = yield (0, _effects.select)(state => state.auth);

  if (isMfaRequired(user)) {
    const mfaRequiredState = yield getMfaRequiredState(user);
    yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
    onRedirectTo(routes.loginUrl, {
      preserveQueryParams: true
    });
  }
}

function* requestAuthorizeSSR({
  payload
}) {
  const calls = [];
  yield (0, _effects.put)(_reducer.actions.loadSocialLoginsConfigurationV2());
  calls.push((0, _effects.call)(_saga.loadAllowSignUps));
  calls.push((0, _effects.call)(loadSSOPublicConfigurationFunction));
  calls.push((0, _effects.call)(_saga2.loadVendorPublicInfo));
  calls.push((0, _effects.call)(refreshMetadata));
  calls.push((0, _effects.call)(isMFARequiredSSR, payload));
  yield (0, _effects.all)(calls);
}

const getUri = urlStrategy => {
  if (urlStrategy === 'path') {
    var _window3;

    return ((_window3 = window) != null ? _window3 : document).location.pathname;
  } else {
    var _window4;

    let uri = (((_window4 = window) != null ? _window4 : document).location.hash || '#').substring(1);

    if (uri.indexOf('?') !== -1) {
      return uri.substring(0, uri.indexOf('?'));
    } else {
      return uri;
    }
  }
};

function* requestHostedLoginSilentAuthorize() {
  const user = yield (0, _effects.call)(_restApi.api.auth.silentOAuthRefreshToken);

  if (user) {
    yield (0, _effects.put)(_reducer.actions.setState({
      user,
      isAuthenticated: true
    }));
    yield (0, _effects.put)(_reducer.actions.loadTenants());
    yield (0, _effects.put)(_reducer.actions.setState({
      isLoading: false
    }));
  } else {
    throw new Error(`couldn't refresh user token with oauth service`);
  }
}

function* refreshOrRequestHostedLoginAuthorize({
  payload: additionalParams
}) {
  const {
    disableSilentRefresh
  } = yield (0, _effects.select)(state => ({
    disableSilentRefresh: state.auth.disableSilentRefresh
  }));

  try {
    if (disableSilentRefresh) {
      throw new Error('silent refresh is disabled');
    }

    yield requestHostedLoginSilentAuthorize();
  } catch (e) {
    yield requestHostedLoginAuthorize(additionalParams);
  }
}

function* requestHostedLoginAuthorize(additionalParams) {
  const {
    routes,
    context,
    onRedirectTo,
    urlStrategy
  } = yield (0, _effects.select)(state => ({
    routes: state.auth.routes,
    onRedirectTo: state.auth.onRedirectTo,
    context: state.root.context,
    urlStrategy: state.root.urlStrategy
  }));
  const activeUri = getUri(urlStrategy);

  if (activeUri === routes.hostedLoginRedirectUrl) {
    console.debug('Calling loginWithRedirect while in hostedLoginCallback route');
    return;
  }

  yield (0, _effects.put)(_reducer.actions.setState({
    isLoading: true
  })); // Generate the relevant params for the redirect

  const nonce = (0, _helpers.createRandomString)();
  const code_verifier = (0, _helpers.createRandomString)();
  const code_challenge = yield (0, _effects.call)(_helpers.generateCodeChallenge, code_verifier); // We are saving the verifier in session storage to be able to validate the response

  localStorage.setItem(_constants.HOSTED_LOGIN_VERIFIER_KEY, code_verifier);
  const redirectUrl = `${window.location.origin}${urlStrategy === 'path' ? '' : '#'}${routes.hostedLoginRedirectUrl}`;

  const baseUrl = _restApi.fetch.getBaseUrl(context, '/oauth/authorize'); // Hard coded for now


  const oauthUrl = `${baseUrl}/oauth/authorize`;
  const params = (0, _extends2.default)({
    response_type: 'code',
    client_id: context.clientId || 'INVALID-CLIENT-ID',
    scope: 'openid email profile',
    redirect_uri: redirectUrl,
    code_challenge: code_challenge,
    code_challenge_method: 'S256',
    nonce
  }, additionalParams);
  const searchParams = new URLSearchParams(params);
  const url = `${oauthUrl}?${searchParams.toString()}`;
  onRedirectTo(url, {
    refresh: true
  });
}

function* handleHostedLoginCallback({
  payload
}) {
  // Hard coded for now
  const code_verifier = localStorage.getItem(_constants.HOSTED_LOGIN_VERIFIER_KEY) || 'INVALID-CODE-VERIFIER';
  const {
    routes,
    urlStrategy
  } = yield (0, _effects.select)(state => ({
    routes: state.auth.routes,
    urlStrategy: state.root.urlStrategy
  }));
  const redirectUrl = `${window.location.origin}${urlStrategy === 'path' ? '' : '#'}${routes.hostedLoginRedirectUrl}`;
  const body = {
    code: payload.code,
    redirect_uri: redirectUrl,
    code_verifier,
    grant_type: 'authorization_code'
  };

  try {
    const user = yield (0, _effects.call)(_restApi.api.auth.exchangeOAuthTokens, body); // TODO: Validate nonce and aud

    yield (0, _effects.put)(_reducer.actions.setState({
      user,
      isAuthenticated: true
    }));
    yield (0, _effects.put)(_reducer.actions.loadTenants());
  } catch (e) {
    console.error('Failed to exchangeOAuthTokens', e);
  } finally {
    yield afterAuthNavigation();
  }
}

function* changePhoneNumberWithVerification(_ref2) {
  let {
    payload: {
      callback
    }
  } = _ref2,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref2.payload, _excluded);

  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const changePhoneRes = yield (0, _effects.call)(_restApi.api.auth.changePhoneNumberWithVerification, payload);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      phoneNumber: payload.phoneNumber,
      loading: false,
      changePhoneId: changePhoneRes.changePhoneId,
      step: _interfaces2.LoginStep.loginWithQuickSmsOtc,
      error: undefined
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message,
      loading: false
    }));
  }
}

function* verifyChangePhoneNumber(_ref3) {
  let {
    payload: {
      callback
    }
  } = _ref3,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref3.payload, _excluded2);

  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    yield (0, _effects.call)(_restApi.api.auth.verifyChangePhoneNumber, payload);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message,
      loading: false
    }));
  }
}

function* quickSmsPasswordlessPreLogin(_ref4) {
  let {
    payload: {
      callback
    }
  } = _ref4,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref4.payload, _excluded3);

  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    })); // TODO: [Typescript 4.8] fix @frontegg/rest-api return value
    // @ts-ignore

    const preloginRes = yield (0, _effects.call)(_restApi.api.auth.passwordlessPreLogin, (0, _extends2.default)({}, payload, {
      type: _restApi.AuthStrategyEnum.SmsCode
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithQuickSmsOtc,
      loading: false,
      phoneNumber: preloginRes == null ? void 0 : preloginRes.phoneNumber,
      error: undefined
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message,
      loading: false
    }));
    callback == null ? void 0 : callback(e);
  }
}

function* passwordlessPreLogin(_ref5) {
  let {
    payload: {
      callback
    }
  } = _ref5,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref5.payload, _excluded4);

  try {
    const {
      onRedirectTo,
      routes
    } = yield (0, _effects.select)(({
      auth: {
        onRedirectTo,
        routes
      }
    }) => ({
      onRedirectTo,
      routes
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    })); // TODO: [Typescript 4.8] fix @frontegg/rest-api return value
    // @ts-ignore

    const preloginRes = yield (0, _effects.call)(_restApi.api.auth.passwordlessPreLogin, payload);
    const step = authStrategyLoginStepMap[payload.type];

    if (step === _interfaces2.LoginStep.loginWithSmsOtc && preloginRes.resetPhoneNumberToken) {
      yield (0, _effects.put)(_reducer.actions.setResetPhoneNumberState({
        resetPhoneNumberToken: preloginRes.resetPhoneNumberToken,
        step: _interfaces5.ResetPhoneNumberStep.VerifyResetPhoneNumber
      }));
      onRedirectTo(routes.resetPhoneNumberUrl);
      return;
    }

    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step,
      loading: false,
      phoneNumber: preloginRes == null ? void 0 : preloginRes.phoneNumber,
      email: payload.email,
      error: undefined
    }));
    callback == null ? void 0 : callback();
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message,
      loading: false
    }));
    callback == null ? void 0 : callback();
  }
}

function* passwordlessPostLogin(_ref6) {
  let {
    payload: {
      callback,
      events
    }
  } = _ref6,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref6.payload, _excluded5);

  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const data = yield (0, _effects.call)(_restApi.api.auth.passwordlessPostLogin, payload);
    const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
    const {
      routes
    } = yield (0, _effects.select)(state => state.auth);

    if (isMfaRequired(data)) {
      const mfaRequiredState = yield getMfaRequiredState(data);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      const {
        loginState
      } = yield (0, _effects.select)(state => state.auth);
      const user = yield (0, _effects.call)(_restApi.api.auth.generateLoginResponse, data);

      if (data.emailVerified) {
        var _events$userVerified;

        events == null ? void 0 : (_events$userVerified = events.userVerified) == null ? void 0 : _events$userVerified.call(events, {
          email: user.email,
          origin: _interfaces.UserVeirifedOriginTypes.PASSWORDLESS,
          id: user.id,
          tenantId: user.tenantId,
          createdAt: new Date(),
          name: user.name
        });
      }

      if (user.id) {
        localStorage.setItem('userId', user.id);
      }

      yield (0, _effects.put)(_reducer.actions.setState({
        user,
        isAuthenticated: true
      }));
      yield (0, _effects.put)(_reducer.actions.setLoginState({
        error: undefined
      }));
      yield (0, _effects.put)(_reducer.actions.loadTenants());

      if (loginState.flow === _interfaces2.LoginFlow.Login) {
        yield afterAuthNavigation();
      } else {
        onRedirectTo(routes.loginUrl, {
          preserveQueryParams: true
        });
      }

      localStorage.removeItem('register-quick-login');
      callback == null ? void 0 : callback(true);
    }
  } catch (e) {
    var _e$message;

    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (_e$message = e.message) != null ? _e$message : 'Failed to authenticate'
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}

function* verifyInviteToken({
  payload
}) {
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const {
      name: inviteTokenTenantName
    } = yield (0, _effects.call)(_restApi.api.auth.verifyInviteToken, payload);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      inviteTokenTenantName
    }));
  } catch (e) {
    var _e$message2;

    console.error(e);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      inviteTokenError: (_e$message2 = e.message) != null ? _e$message2 : `We couldn't verify your invitation`
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}

function* preLogin({
  payload: {
    email,
    recaptchaToken,
    invitationToken,
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const onRedirectTo = yield (0, _effects.select)(({
      auth: {
        onRedirectTo
      }
    }) => onRedirectTo);
    let {
      address,
      idpType
    } = yield (0, _effects.call)(_restApi.api.auth.preLoginV2, {
      email
    });

    if (address) {
      if (idpType === _interfaces4.SamlVendors.Oidc && !address.includes('redirect_uri')) {
        const {
          routes: {
            oidcRedirectUrl
          }
        } = yield (0, _effects.select)(({
          auth: {
            routes
          }
        }) => ({
          routes
        }));
        address += `&redirect_uri=${window.location.origin}${oidcRedirectUrl}`;
      }

      yield (0, _effects.put)(_reducer.actions.setLoginState({
        step: _interfaces2.LoginStep.redirectToSSO,
        loading: false,
        ssoRedirectUrl: address
      }));
      setTimeout(() => {
        onRedirectTo(address, {
          refresh: true
        });
      }, 2000);
    } else {
      yield ssoPreloginFailed({
        email,
        recaptchaToken,
        callback,
        invitationToken
      });
    }
  } catch (e) {
    yield ssoPreloginFailed({
      email,
      recaptchaToken,
      callback,
      invitationToken
    });
  }
}

function* ssoPreloginFailed(_ref7) {
  let {
    callback
  } = _ref7,
      body = (0, _objectWithoutPropertiesLoose2.default)(_ref7, _excluded6);
  const publicPolicy = yield (0, _effects.select)(({
    auth: {
      securityPolicyState: {
        publicPolicy: {
          policy: publicPolicy
        }
      }
    }
  }) => publicPolicy);

  if (!(publicPolicy != null && publicPolicy.authStrategy)) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithPassword,
      loading: false
    }));
    callback == null ? void 0 : callback();
    return;
  }

  if ((publicPolicy == null ? void 0 : publicPolicy.authStrategy) === _restApi.AuthStrategyEnum.EmailAndPassword) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithPassword,
      loading: false
    }));
    callback == null ? void 0 : callback();
  } else if ([_restApi.AuthStrategyEnum.MagicLink, _restApi.AuthStrategyEnum.Code, _restApi.AuthStrategyEnum.SmsCode].includes(publicPolicy == null ? void 0 : publicPolicy.authStrategy)) {
    yield (0, _effects.put)(_reducer.actions.passwordlessPreLogin((0, _extends2.default)({}, body, {
      type: publicPolicy == null ? void 0 : publicPolicy.authStrategy,
      callback
    })));
  } else {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithPassword,
      loading: false
    }));
    callback == null ? void 0 : callback();
  }
}

function* webAuthnCreateNewDeviceSession({
  payload: {
    callback
  }
}) {
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const {
      options
    } = yield (0, _effects.call)(_restApi.api.auth.webAuthnCreateNewDeviceSession);
    options.user.id = (0, _utils.base64urlDecode)(options.user.id);
    options.challenge = (0, _utils.base64urlDecode)(options.challenge);
    options.excludeCredentials = [];
    callback == null ? void 0 : callback(options);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}

function* webAuthnVerifyNewDeviceSession(_ref8) {
  let {
    payload: {
      callback
    }
  } = _ref8,
      body = (0, _objectWithoutPropertiesLoose2.default)(_ref8.payload, _excluded7);

  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const publicKey = (0, _utils.publicKeyCredentialToJSON)(body.publicKey);
    yield (0, _effects.call)(_restApi.api.auth.verifyNewDeviceSession, {
      id: publicKey.id,
      response: publicKey.response
    });
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}

function* webAuthnPrelogin(_ref9) {
  let {
    payload: {
      callback
    }
  } = _ref9,
      body = (0, _objectWithoutPropertiesLoose2.default)(_ref9.payload, _excluded8);

  try {
    var _options$allowCredent;

    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const {
      options
    } = yield (0, _effects.call)(_restApi.api.auth.webAuthnPreLogin, body);
    options.challenge = (0, _utils.base64urlDecode)(options.challenge);
    options.allowCredentials = (_options$allowCredent = options.allowCredentials) == null ? void 0 : _options$allowCredent.map(credentials => (0, _extends2.default)({}, credentials, {
      id: (0, _utils.base64urlDecode)(credentials.id)
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: undefined
    }));
    callback == null ? void 0 : callback(options);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}

function* webAuthnPostLogin(_ref10) {
  let {
    payload: {
      callback
    }
  } = _ref10,
      body = (0, _objectWithoutPropertiesLoose2.default)(_ref10.payload, _excluded9);

  try {
    var _publicKey$response$u;

    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const publicKey = (0, _utils.publicKeyCredentialToJSON)(body.publicKey);
    const data = yield (0, _effects.call)(_restApi.api.auth.webAuthnPostLogin, (0, _extends2.default)({}, publicKey, {
      response: (0, _extends2.default)({}, publicKey.response, {
        userHandle: (_publicKey$response$u = publicKey.response.userHandle) != null ? _publicKey$response$u : undefined
      }),
      recaptchaToken: body.recaptchaToken,
      invitationToken: body.invitationToken
    }));

    if (isMfaRequired(data)) {
      const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
      const {
        routes
      } = yield (0, _effects.select)(state => state.auth);
      const mfaRequiredState = yield getMfaRequiredState(data);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      const user = yield (0, _effects.call)(_restApi.api.auth.generateLoginResponse, data);

      if (user.id) {
        localStorage.setItem('userId', user.id);
      }

      yield (0, _effects.put)(_reducer.actions.loadTenants());
      yield (0, _effects.put)(_reducer.actions.setState({
        user,
        isAuthenticated: true
      }));
      yield (0, _effects.put)(_reducer.actions.setLoginState({
        error: undefined
      }));
      yield afterAuthNavigation(); // TODO: Itamar why moving callback to inside the else block

      callback == null ? void 0 : callback(true);
    } // callback?.(true);

  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}

function* postLogin({
  payload
}) {
  const {
    onRedirectTo,
    routes
  } = yield (0, _effects.select)(({
    auth: {
      onRedirectTo,
      routes
    }
  }) => ({
    onRedirectTo,
    routes
  }));
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const user = yield (0, _effects.call)(_restApi.api.auth.postLogin, payload);

    _restApi.ContextHolder.setAccessToken(user.accessToken);

    _restApi.ContextHolder.setUser(user);

    yield (0, _effects.put)(_reducer.actions.setState({
      user: !!user.accessToken ? user : undefined,
      isAuthenticated: !!user.accessToken
    }));
    yield afterAuthNavigation();
  } catch (e) {
    setTimeout(() => {
      onRedirectTo(routes.authenticatedUrl);
    }, 1000);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithSSOFailed,
      loading: false
    }));
  }
}

function* login({
  payload: {
    email,
    password,
    recaptchaToken,
    invitationToken,
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const user = yield (0, _effects.call)(_restApi.api.auth.login, {
      email,
      password,
      recaptchaToken,
      invitationToken
    });

    _restApi.ContextHolder.setAccessToken(user.accessToken);

    _restApi.ContextHolder.setUser(user);

    const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
    const {
      routes
    } = yield (0, _effects.select)(state => state.auth);

    if (isMfaRequired(user)) {
      const mfaRequiredState = yield getMfaRequiredState(user);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      const {
        loginState
      } = yield (0, _effects.select)(state => state.auth);
      const isAuthenticated = !!user.accessToken;

      if (user.id) {
        localStorage.setItem('userId', user.id);
      }

      yield (0, _effects.put)(_reducer.actions.setState({
        user,
        isAuthenticated,
        loginState: {
          flow: loginState.flow,
          quickLoginToRegister: loginState.quickLoginToRegister,
          email,
          loading: false,
          error: undefined,
          mfaToken: user.mfaToken,
          step: loginState.flow === _interfaces2.LoginFlow.Login ? _interfaces2.LoginStep.success : loginState.step,
          tenants: [],
          tenantsLoading: true
        }
      }));
      yield (0, _effects.put)(_reducer.actions.loadTenants());

      if (isAuthenticated && loginState.flow === _interfaces2.LoginFlow.Login) {
        yield afterAuthNavigation();
      }
    } // TODO: extract item name to constants


    localStorage.removeItem('register-quick-login');
    callback == null ? void 0 : callback(true);
  } catch (e) {
    _restApi.ContextHolder.setAccessToken(null);

    _restApi.ContextHolder.setUser(null);

    yield (0, _effects.put)(_reducer.actions.setLoginState({
      email,
      error: e.message,
      loading: false
    }));
  }
}

function* loginWithMfa({
  payload: {
    mfaToken,
    value,
    rememberDevice,
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const user = yield (0, _effects.call)(_restApi.api.auth.loginWithMfa, {
      mfaToken,
      value,
      rememberDevice
    });
    const {
      loginState
    } = yield (0, _effects.select)(state => state.auth);
    const step = loginState.flow === _interfaces2.LoginFlow.Login ? _interfaces2.LoginStep.success : loginState.step;
    yield (0, _effects.put)(_reducer.actions.setState({
      loginState: {
        flow: loginState.flow,
        quickLoginToRegister: loginState.quickLoginToRegister,
        loading: false,
        step,
        error: undefined,
        tenantsLoading: true,
        tenants: []
      },
      user,
      isAuthenticated: true
    }));

    if (user.id) {
      localStorage.setItem('userId', user.id);
    }

    yield (0, _effects.put)(_reducer.actions.loadTenants());
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: undefined,
      loading: false
    }));

    if (loginState.flow === _interfaces2.LoginFlow.Login) {
      yield afterAuthNavigation();
    }

    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message,
      loading: false
    }));
    callback == null ? void 0 : callback(false, e);
  }
}

function* recoverMfa({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    yield (0, _effects.call)(_restApi.api.auth.recoverMfaToken, payload);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: undefined,
      step: _interfaces2.LoginStep.preLogin
    }));
    yield (0, _effects.put)(_reducer.actions.setState({
      user: undefined,
      isAuthenticated: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: e.message,
      loading: false
    }));
  }
}

function* logout({
  payload
}) {
  const {
    hostedLoginBox
  } = yield (0, _effects.select)(state => state.auth);
  yield (0, _effects.put)(_reducer.actions.setState({
    isLoading: true
  }));

  try {
    if (hostedLoginBox) {
      yield (0, _effects.call)(_restApi.api.auth.OAuthLogout);
    } else {
      yield (0, _effects.call)(_restApi.api.auth.logout);
    }
  } catch {}

  yield (0, _effects.put)(_reducer.actions.resetState());
  yield (0, _effects.put)(_reducer.actions.requestAuthorize(true));
  payload == null ? void 0 : payload();
}

function* silentLogout({
  payload
}) {
  var _payload$callbackTime;

  try {
    yield (0, _effects.call)(_restApi.api.auth.logout);
  } catch {}

  setTimeout(() => {
    var _payload$callback;

    return payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
  }, (_payload$callbackTime = payload == null ? void 0 : payload.callbackTimeout) != null ? _payload$callbackTime : 500);
}

function* handleEnrollMFAResponse({
  user,
  tenants
}) {
  const mfaState = {
    step: _interfaces3.MFAStep.recoveryCode,
    loading: false,
    error: undefined,
    saving: false
  };

  if (user != null && user.recoveryCode) {
    mfaState.recoveryCode = user.recoveryCode;
  }

  yield (0, _effects.put)(_reducer.actions.setMfaState(mfaState));
  yield (0, _effects.put)(_reducer.actions.setUser(user));
  yield (0, _effects.put)(_reducer.actions.setTenantsState({
    tenants,
    loading: false
  }));

  if (user.id) {
    localStorage.setItem('userId', user.id);
  }
}

function* handleVerifyMFAResponse({
  user,
  tenants
}) {
  const {
    loginState
  } = yield (0, _effects.select)(state => state.auth);
  yield (0, _effects.put)(_reducer.actions.setUser(user));
  yield (0, _effects.put)(_reducer.actions.setTenantsState({
    tenants,
    loading: false
  }));

  if (user.id) {
    localStorage.setItem('userId', user.id);
  }

  if (loginState.flow === _interfaces2.LoginFlow.Login) {
    yield afterAuthNavigation();
  }

  yield (0, _effects.put)(_reducer.actions.setState({
    isAuthenticated: true
  }));
}

function* preEnrollMFASMSForLogin(_ref11) {
  let {
    payload: {
      callback
    }
  } = _ref11,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref11.payload, _excluded10);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const data = yield (0, _effects.call)(_restApi.api.auth.preEnrollMFASMSForLogin, payload);
    yield (0, _effects.put)(_reducer.actions.setMfaState({
      otcToken: data.otcToken,
      step: _interfaces3.MFAStep.smsVerifyCode,
      phoneNumber: data.phoneNumber
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  }
}

function* enrollMFASMSForLogin(_ref12) {
  let {
    payload: {
      callback
    }
  } = _ref12,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref12.payload, _excluded11);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const data = yield (0, _effects.call)(_restApi.api.auth.enrollMFASMSForLogin, payload);
    const response = yield (0, _effects.call)(_restApi.api.auth.generateLoginResponseV2, data);
    yield handleEnrollMFAResponse(response);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  }
}

function* preEnrollMFAWebAuthnForLogin(_ref13) {
  let {
    payload: {
      callback
    }
  } = _ref13,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref13.payload, _excluded12);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    var _data$options$exclude;

    const data = yield (0, _effects.call)(_restApi.api.auth.preEnrollMFAWebAuthnForLogin, payload);
    const options = (0, _extends2.default)({}, data.options, {
      challenge: (0, _utils.base64urlDecode)(data.options.challenge),
      user: (0, _extends2.default)({}, data.options.user, {
        id: (0, _utils.base64urlDecode)(data.options.user.id)
      }),
      excludeCredentials: (_data$options$exclude = data.options.excludeCredentials) == null ? void 0 : _data$options$exclude.map(credentials => (0, _extends2.default)({}, credentials, {
        id: (0, _utils.base64urlDecode)(credentials.id)
      }))
    });
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback({
      options,
      webauthnToken: data.webauthnToken
    });
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  }
}

function* enrollMFAWebAuthnForLogin(_ref14) {
  let {
    payload: {
      callback
    }
  } = _ref14,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref14.payload, _excluded13);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const publicKey = (0, _utils.publicKeyCredentialToJSON)(payload.publicKey);
    const data = yield (0, _effects.call)(_restApi.api.auth.enrollMFAWebAuthnForLogin, (0, _extends2.default)({}, payload, {
      options: publicKey
    }));
    const response = yield (0, _effects.call)(_restApi.api.auth.generateLoginResponseV2, data);
    yield handleEnrollMFAResponse(response);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  }
}

function* enrollMFAAuthenticatorAppForLogin(_ref15) {
  let {
    payload: {
      callback
    }
  } = _ref15,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref15.payload, _excluded14);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const data = yield (0, _effects.call)(_restApi.api.auth.enrollMFAAuthenticatorAppForLogin, payload);
    const response = yield (0, _effects.call)(_restApi.api.auth.generateLoginResponseV2, data);
    yield handleEnrollMFAResponse(response);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  }
}

function* preVerifyMFASMSForLogin(_ref16) {
  let {
    payload: {
      callback,
      deviceId
    }
  } = _ref16,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref16.payload, _excluded15);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const data = yield (0, _effects.call)(_restApi.api.auth.preVerifyMFASMSForLogin, deviceId, payload);
    yield (0, _effects.put)(_reducer.actions.setMfaState({
      otcToken: data.otcToken,
      step: _interfaces3.MFAStep.smsVerifyCode,
      phoneNumber: data.phoneNumber
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  }
}

function* verifyMFASMSForLogin(_ref17) {
  let {
    payload: {
      callback,
      deviceId
    }
  } = _ref17,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref17.payload, _excluded16);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const data = yield (0, _effects.call)(_restApi.api.auth.verifyMFASMSForLogin, deviceId, payload);
    const response = yield (0, _effects.call)(_restApi.api.auth.generateLoginResponseV2, data);
    yield handleVerifyMFAResponse(response);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  }
}

function* preVerifyMFAWebAuthnForLogin(_ref18) {
  let {
    payload: {
      callback,
      deviceId
    }
  } = _ref18,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref18.payload, _excluded17);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    var _data$options$allowCr;

    const data = yield (0, _effects.call)(_restApi.api.auth.preVerifyMFAWebAuthnForLogin, deviceId, payload);
    const options = (0, _extends2.default)({}, data.options, {
      challenge: (0, _utils.base64urlDecode)(data.options.challenge),
      allowCredentials: (_data$options$allowCr = data.options.allowCredentials) == null ? void 0 : _data$options$allowCr.map(credentials => (0, _extends2.default)({}, credentials, {
        id: (0, _utils.base64urlDecode)(credentials.id)
      }))
    });
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback({
      options,
      webauthnToken: data.webauthnToken
    });
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  }
}

function* verifyMFAWebAuthnForLogin(_ref19) {
  let {
    payload: {
      callback,
      deviceId
    }
  } = _ref19,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_ref19.payload, _excluded18);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));

  try {
    const publicKey = (0, _utils.publicKeyCredentialToJSON)(payload.publicKey);
    const data = yield (0, _effects.call)(_restApi.api.auth.verifyMFAWebAuthnForLogin, deviceId, (0, _extends2.default)({}, payload, {
      options: publicKey
    }));
    const response = yield (0, _effects.call)(_restApi.api.auth.generateLoginResponseV2, data);
    yield handleVerifyMFAResponse(response);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: e.message
    }));
    callback == null ? void 0 : callback(null);
  }
}

function* loginSagas() {
  yield (0, _effects.takeLeading)(_reducer.actions.requestAuthorize, requestAuthorize);
  yield (0, _effects.takeLeading)(_reducer.actions.requestAuthorizeSSR, requestAuthorizeSSR);
  yield (0, _effects.takeLeading)(_reducer.actions.requestHostedLoginAuthorize, refreshOrRequestHostedLoginAuthorize);
  yield (0, _effects.takeLeading)(_reducer.actions.handleHostedLoginCallback, handleHostedLoginCallback);
  yield (0, _effects.takeLeading)(_reducer.actions.preLogin, preLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.postLogin, postLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.login, login);
  yield (0, _effects.takeLeading)(_reducer.actions.logout, logout);
  yield (0, _effects.takeLeading)(_reducer.actions.silentLogout, silentLogout);
  yield (0, _effects.takeLeading)(_reducer.actions.loginWithMfa, loginWithMfa);
  yield (0, _effects.takeLeading)(_reducer.actions.recoverMfa, recoverMfa);
  yield (0, _effects.takeLeading)(_reducer.actions.quickSmsPasswordlessPreLogin, quickSmsPasswordlessPreLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.changePhoneNumberWithVerification, changePhoneNumberWithVerification);
  yield (0, _effects.takeLeading)(_reducer.actions.verifyChangePhoneNumber, verifyChangePhoneNumber);
  yield (0, _effects.takeLeading)(_reducer.actions.passwordlessPreLogin, passwordlessPreLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.passwordlessPostLogin, passwordlessPostLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.verifyInviteToken, verifyInviteToken);
  yield (0, _effects.takeLeading)(_reducer.actions.webAuthnPrelogin, webAuthnPrelogin);
  yield (0, _effects.takeLeading)(_reducer.actions.webAuthnPostLogin, webAuthnPostLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.webAuthnCreateNewDeviceSession, webAuthnCreateNewDeviceSession);
  yield (0, _effects.takeLeading)(_reducer.actions.webAuthnVerifyNewDeviceSession, webAuthnVerifyNewDeviceSession);
  yield (0, _effects.takeLeading)(_reducer.actions.afterAuthNavigation, afterAuthNavigation);
  yield (0, _effects.takeLeading)(_reducer.actions.getUserIP, getUserIP);
  yield (0, _effects.takeLeading)(_reducer.actions.preEnrollMFASMSForLogin, preEnrollMFASMSForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.enrollMFASMSForLogin, enrollMFASMSForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.preEnrollMFAWebAuthnForLogin, preEnrollMFAWebAuthnForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.enrollMFAWebAuthnForLogin, enrollMFAWebAuthnForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.enrollMFAAuthenticatorAppForLogin, enrollMFAAuthenticatorAppForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.preVerifyMFASMSForLogin, preVerifyMFASMSForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.verifyMFASMSForLogin, verifyMFASMSForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.preVerifyMFAWebAuthnForLogin, preVerifyMFAWebAuthnForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.verifyMFAWebAuthnForLogin, verifyMFAWebAuthnForLogin);
}
/*********************************
 *  Preview Sagas
 *********************************/


function* requestAuthorizeMock({
  payload: firstTime
}) {
  if (firstTime) {
    yield (0, _effects.put)(_reducer.actions.setState({
      isLoading: true
    }));
  }

  const user = _dummy.userDemo;
  yield (0, _effects.put)(_reducer.actions.loadTenants());
  yield (0, _effects.put)(_reducer.actions.setState({
    user,
    isAuthenticated: true,
    isLoading: false
  }));
}

function* getUserIPMock({
  payload: {
    callback
  }
}) {
  try {
    const {
      ip
    } = _dummy.dummyIps[0];
    yield (0, _effects.put)(_reducer.actions.setState({
      userIp: ip
    }));
    callback == null ? void 0 : callback(true, ip);
  } catch (e) {
    callback == null ? void 0 : callback(false, e);
  }
}

function* loginSagasMock() {
  yield (0, _effects.takeLeading)(_reducer.actions.requestAuthorize, requestAuthorizeMock);
  yield (0, _effects.takeLeading)(_reducer.actions.afterAuthNavigation, afterAuthNavigation);
  yield (0, _effects.takeLeading)(_reducer.actions.getUserIP, getUserIPMock);
}